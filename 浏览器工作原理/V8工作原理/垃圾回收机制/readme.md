# 垃圾回收

1. 手动回收 (例如：c/c++)

2. 自动回收 (例如：java，python)

# 栈中的垃圾数据和堆中的垃圾数据是怎么回收的
  栈中的垃圾数据
  - javascript引擎会通过向下移动ESP指针来销毁函数保存在执行栈中的函数执行上下文

  堆中的垃圾数据
  - 

# 代际假说 和 分代收集

  代际假说（人为的一种认知）
   1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经内存分配，很快就变得不可访问。
   2. 不死的对象会活得很久


v8会把堆分成 新生代和老生代
  新生代：存放生存时间短的对象 1 ~ 8M的容量  被副垃圾收收器回收
  老生代：存放生存时间长的对象 被主垃圾回收器回收


  不论什么类型的垃圾回收器，都有一套共用的执行流程
   1. 标记空间中的活动对象（还在使用的对象）和非活动对象（可以进行垃圾回收的对象）
   2. 回收非活动对象所占据的内存
   3. 做内存整理，频繁回收对象后，就会出现大量不连续的空间（内存碎片）

# 副垃圾回收器
  - 主要负责新生区的垃圾回收，通常情况下，大多数小的对象都会被分配到新生区，所以回首是很频繁的
  scavenge算法 会把新生区的内存一分为二，分成对象区域和空闲区域，然后标记对象区域里面所有的对象，把活对象复制到空闲区域，此过程还会做好排序，相当于做了内存整理，然后清空对象区域，再角色翻转。

  当存活对象过多，新生区域空间不够时，js会采用对象晋升策略（经过两次垃圾回收还存活的对象，直接移动到老生区


# 主垃圾回收器
  - 主要负责老生区的垃圾回收，老生区中的对象来自于新生区晋升的对象和本身就很大的对象

  标记-清除的算法，首先是标记阶段（当执行上下文里的代码执行完后，也即ESP指针从该执行上下文指向下一个调用栈元素。主垃圾回收器会递归遍历调用栈里的所有执行上下文里的内存数据，如果该数据还会在后续被使用，但凡能找到一个节点是活对象，那这组对象就是活对象，一个活对象节点都没有的就是垃圾对象）


# 全停顿
  因为JavaScript是运行在v8的主线程上的，而垃圾回收的算法也在主线程，那么就会出现当需要垃圾回收时，js的运行会停顿。要等到垃圾回收完毕后再恢复运行，这就叫做全停顿。

  - 全停顿在新生区是没有太大的影响的，v8将标记过程分成一个个子标记过程，同时让垃圾回收标记和js引用逻辑交替进行，知道标记完成（增量标记算法）




