// 背包模型

// 有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个
// 名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值
// 用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入
// 背包，才能使得背包内的物品总价值最大？
// 注意：每种物品都只有1件


// 定位到问题的终点，站在终点的视角，来思考后退的可能性
// 站在终点时背包里的物品已满，并且是最大价值，我们往回退，用数组的下标i为一个参数表示在将要取第i件物品时背包的状态。要取走的这件
// 物品可能在背包中，也可能不在

// 不在背包时,取走当前下标的物品对背包的状态(背包的总价值)无影响,取完后的状态就是将要取i - 1下标时背包的状态
// f(i, c) = f(i - 1, c)

// 在背包时
// f(i, c) - value[i] = f(i - 1, c - w[i])
// f(i, c) = f(i - 1, c - w[i]) + value[i]
// f(i, c) 表示当前背包的状态，物品数组的下标记为i，c表示当前状态时背包的体积。依次遍历数组的同时计算当前背包在取出下标物品和没有取出时背包的总价值
// 并取最大值时的状态

// 状态转移方程

// for (let i = 1; i <= n; i++) {
//   for (let v = w[i]; v <= c; v++) {
//     dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v - w[i]] + value[i])
//   }
// }

const knaspssack = (n, c, w, value) => {
  let dp = [4][5] = 0
  for (let i = 0; i < n; i++) {
    for (let v = c; v >= w[i]; i++) {
      
    }
  }
}
